//位运算性质
#include <stdio.h>
int tong[31] = {0};
int main()
{
    int n, t, ans;
    scanf("%d", &n);
    scanf("%d", &ans);
    for (int i = 1; i < n; i++)
    {
        scanf("%d", &t);
        ans ^= t;
    }
    printf("%d", ans);
    return 0;
}
/*
Description
​ DDL 看着各路出题人各种放飞自我，感到非常地悲伤，于是他想出一套真正的“程序设计题”。

​ 当然，是在梦里。~~梦里什么都有~~

​ 在梦中，脸盲 DDL 牵着 m=2k+1 个数，其中有 k 对一样的数[1]，还有一个独一无二的小可爱。

​ 好梦难求，一个 bug 将梦砸得支离破碎，DDL 只来得及保护住那一个小可爱，回头一看，那 k 对数中每一对恰好有一个数被撕裂了，撕成了二进制的碎片[2]。

​ ……

​ 现在 DDL 牵着 n 个数，他想知道那一个小可爱的值是多少。

​ [1] 每一对数 (a,b) 中 a=b ，但是数对之间的值不一定相等。

​ [2] 对于一个数 num ，如果它被分裂成了 x (x≥1) 个碎片（每个碎片是一个数），则这 x 个碎片满足对任意两个碎片 numa，numb 有 numa&numb=0 ，所有碎片加起来等于 num 。碎片都是正数，且有可能只产生一个碎片，即原本的数。

​ 掌握了时间魔法的 STA 注意到了这件事，为了下调难度，他挽回了一半的破碎的梦。也就是说，测试中的 50% 标准数据中的 n=2k+1 个数即为 k 对数加一个单独的数。

Input​
​ 第一行一个数 n (n≤100,000) 。

​ 第二行 n 个非负整数，在 int 范围内。

Output
​ 一行，输出小可爱的值。

Sample Input
3

1 2 2

Sample Output
1
*/