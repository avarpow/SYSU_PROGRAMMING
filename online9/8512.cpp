//模拟
#include <stdio.h>
#include <string.h>
int a[1005], b[1005];
int main()
{
    int n, m, k;
    scanf("%d%d%d", &n, &m, &k);
    for (int i = 0; i < m; i++)
    {
        scanf("%d", &a[i]);
    }
    b[0] = a[0] - 1;
    for (int i = 1; i < m; i++)
    {
        b[i] = a[i] - a[i - 1] - 1;
    }
    b[m] = n - a[m - 1];
    int B = n - m;
    while (k >= (B + m))
    {
        k -= B + m;
        B *= 2;
        for (int i = 0; i <= m; i++)
        {
            b[i] *= 2;
        }
    }
    while (k > 0)
    {
        for (int i = 0; i <= m; i++)
        {
            if (k <= b[i])
            {
                B += k;
                k = 0;
                break;
            }
            else
            {
                B += b[i];
                k -= b[i];
            }
            if (i != m)
            {
                k--;
            }
        }
    }
    printf("%d", B + m);
    return 0;
}
/*
题目描述
经过几天链表题目的历练，我们可爱的小蒟蒻身心俱疲，于是他打开了他最喜欢的游戏《炉石传说》。 几盘下来，小蒟蒻打上了传说，顿时觉得索然无味，于是他决定设计起自己的卡牌游戏。小蒟蒻设计的卡牌游戏规则如下： 这款游戏中，卡牌只有 A 和 B 两种类型， 开始时，蒟蒻的牌库有 n 张牌，牌由上而下垒成一堆，牌顶在上牌底在下。 每回合开始时，小蒟蒻从牌库最上面也就是牌库顶部抽取出一张卡牌，若这张卡牌为 A 类型，则小蒟蒻插入一张新的 A 类型的牌到牌库底部； 但若这张卡牌为 B 类型，则小蒟蒻插入两张新的 B 类型的牌到牌库底部。 A类型的卡牌非常稀有，所以保证开始时A类型卡牌数小于等于牌库内总牌数的0.1%(向上取整)。被抽取出的卡牌不会再洗入牌库内！ 我们的小蒟蒻不太聪明，但是他想知道，经过 k 个回合后，他的牌库里一共有多少张牌？他现在告诉你他开始时他牌库里所有的牌，请聪明的你帮帮他吧！

输入格式
输入的第一行包括三个正整数 n (1≤n≤1000000)、 m(1≤m≤1000) 和 k(1≤k≤1000000000)，分别代表初始时牌库的总牌数，A类型卡牌的张数，和回合数。 输入的第二行包括 m 个正整数a1，a2……am(1≤a1＜a2＜……＜am≤n)，其中 ai 表示第 i 张A类型的牌处在从牌库顶往牌库底数的第 ai 张牌。

输出格式
你需要输出一行一个整数 ans，表示 k 轮结束后小蒟蒻牌库内牌的总数。相邻两个数中间有一个空格！

样例输入
3 1 1
2
样例输出
4
*/