//线性求逆元，卡特兰数
#include <stdio.h>
#define MOD 1000000009
long long a[100000] = {0, 1};
long long inv[110000];
long long last, now = 1;
int main()
{
    int n;
    scanf("%d", &n);
    inv[1] = 1;
    for (int i = 2; i <= n + 1; i++)
        inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD;
    for (int i = 2; i <= n; i++)
    {
        a[i] = a[i - 1] * (4 * i - 2) % MOD * inv[i + 1] % MOD;
    }
    printf("%lld", a[n]);
    return 0;
}
/*
题目描述
因为之前STA回错了每个人的消息，所以已经没人来问STA问题了，STA也终于获得了一天珍贵的假期，决定去找朋友阿玮玩。

不巧的是阿玮今天正好在咖啡厅打工，STA有点烦闷，只好点了杯奶茶，坐在咖啡厅里消磨时间。这时STA发现对面的面包店有一堆男的和一堆女的排队，STA数了数，惊奇地发现男性和女性的数目是一样的，而且从队头开始数，到任何一个位置，女性的数量都不会小于男性的数量。不过因为隔得有点远，STA分不出来这些男性彼此之间有什么差别，女性亦然。

STA坐下来想了想，觉得这种事情不太常见。但是喝了口奶茶之后，STA发现还是有很多种可能的。

于是STA掏出了自己的笔记本，决定写个程序数数一共多少种可能。

输入格式
整数n，表示有n个男性和n个女性在排队。

1≤n≤100000
输出格式
整数m，表示可行的排队方案数

数字有点大，请输出模1e9+9之后的结果。

样例输入
10

样例输出
16796

提示
(a÷b)modn≠((amodn)÷(bmodn))modn
(a÷b)modn=((amodn)×(b−1modn))modn
这里的b−1并不是简单的倒数，而是b对模数n的逆元
*/