/*
一个字符串的子串表示原字符串中一段连续的部分。例如，字符串"121"的子串总共有六个，它们分别是"1"(前一个),"2","1"(后一个),"12","21"和"121"。但"11"不是"121"的子串，因为两个'1'在原串中不连续。我们认为空串也不是子串。

现给你一个只含有'0'和'1'两种字符的字符串，问它含有相同'0'和'1'的字串有几个。例如，字符串"0101"中符合条件的子串有4个。它们分别是"01"(前一个),"10","01"(后一个),"0101"。

Input
输入只有一行，为给定的字符串。字符串长度不超过1000000，且只包含'0'和'1'两种字符。

Output
输出为一个数，表示符合条件的子串的个数。注意最后有一个换行符。

Sample Input
00110011

Sample Output
10

Hint
字符串"00110011"中符合条件的子串分别为"01"(前一个),"10","01"(后一个),"0011"(前一个),"0110","1100","1001","0011"(后一个),"011001","00110011"，共10个。
*/
#include<stdio.h>
#include<string.h>
char s[1000005]={0};
int sum[1000005] = {0};
long long tong[1000005] = {0};
long long ans = 0;
int main(){
    scanf("%s", s+1);
    int len = strlen(s+1);
    for (int i = 1; i <= len;i++){
        if(s[i]=='1')
            sum[i] = sum[i - 1] + 1;
        else{
            sum[i] = sum[i - 1] - 1;
        }
    }
   /* for (int i = 0; i < len;i++){
        for (int j = i + 1; j <= len;j++)
        {
            if(sum[i]==sum[j])
                ans++;
        }
    }*/
    for (int i = 0; i <= len;i++){
        tong[sum[i]+500000]++;
    }
    for (int i = 0; i < 1000005;i++){
        if(tong[i]>0){
            ans =ans+ (tong[i]) * (tong[i] - 1) / 2;
        }
    }
    printf("%lld", ans);
    return 0;
}